# Capstone_Design_2022_1

파일 전송에서의 TCP와 QUIC의 성능 비교

소프트웨어융합학과 김연수
지도 교수 : 이성원

## 서론
지난 몇십년에 걸쳐, 웹 페이지는 점점 더 복잡해지고, 화려해지면서 그에 맞춰 네트워크 프로토콜도 함께 진화해왔다. TCP/IP를 기반으로 동작하는 HTTP가 HTTP/0.9, HTTP/1.0, HTTP/1.1, HTTP/2로 진화할때 까지, TCP 프로토콜이 계속 HTTP에 사용되었다. 하지만, Head-Of Line Blockng 문제와 같은 TCP 프로토콜의 고질적인 문제를 해결할 수 없었기에 Google은 QUIC이라는 이름의 UDP 기반의 프로토콜을 제안하였다. 그리고 QUIC 프로토콜을 기반으로 동작하는 HTTP/3 버전이 공개되었다. 이미 Youtube를 포함한 구글에서 제공하는 상당수의 컨텐츠들이 HTTP/3을 지원하도록 구성되었으며, 클라이언트로는 Chrome, Edge, Firefox, Safari 브라우저가 이미 지원하고있다.
이러한 흐름에 맞춰 최근 QUIC 라이브러리도 다양한 언어로 개발되고 사용되기 시작했으며, 해당 논문에서는 golang으로 작성된 quic-go 라이브러리를 활용해 QUIC을 통해 파일을 전송할 때, 기존 TCP+TLS를 통해 파일을 전송하는것과 어떤 차이가 있는지 직접 서버와 클라이언트를 설계해 실험해보려 한다. 그리고 파일 전송 방식으로 QUIC 병렬 연결을 통한 분할 전송 방식을 제안하고자 한다.

## 기존 기술과 문제점
 TCP 프로토콜은 데이터의 전송 순서를 보장하며, 신뢰성있는 데이터를 전송하는 프로토콜이다. 연결 시에 3-way handshake가 필요하다. 1) 클라이언트에서 서버에 연결 요청을 하기 위해 SYN 데이터를 보내고, 2) 서버에서 SYN 데이터를 받은 후 정상적으로 데이터를 수신했다는 대답(ACK)와 함께 클라이언트도 포트를 열어달라는 신호인 SYN을 함께 보내며, 3) 클라이언트는 SYN, ACK 신호를 받고 포트를 열고 서버에 ACK를 전송하게 된다. 이를 3-way handshake라고 하며, 위와 같이 3번의 통신이 정상적으로 이루어지면 TCP 연결이 완료된다. 데이터 전송 과정에서도 데이터 송신자가 데이터를 보내고, 수신자는 정상적으로 데이터를 수신했을 경우 ACK를 보내는 과정이 필요하며, 이를 통해 데이터의 신뢰성을 확보하게 된다.
하지만 TCP 프로토콜에는 몇 가지 문제점이 존재한다. 우선 TCP는 느리다. 연결에 필요한 3-way handshake에 시간이 너무 많이 소요된다. 보안 연결을 위해 TLS까지 사용한다면 TLS 연결에 필요한 통신이 추가로 필요하게 된다. 또한, 네트워크 어딘가에서 패킷이 삭제되거나 손실된다면 손실된 패킷이 재전송되어 목적지까지 가는 동안 TCP 연결이 중단되는 Head-Of-Line Blocking 문제가 발생한다. 
그림 2는 Head-Of-Line Blocking이 일어나는 예시이다. 좌측은 입력, 우측은 출력 각각 4개씩을 가지고 있으며, 입력 부분 큐의 가장 첫번째 요청들을 처리하는 과정에서, 두번째, 세번째 큐는 각각 1번 출력으로 전달되려 한다. 이 중 두번째 큐를 먼저 처리하게 되면, 세번째 큐의 첫번째 출력은 처리되지 않았기 때문에 두번째 출력 3번이 비어 있음에도 불구하고 세번째 큐는 처리까지 기다려야하는 상황이 발생한다. 이는 심각한 성능 저하를 유발한다.
특히 기존 여러 HTTP/1.1 요청을 동시에 처리하려는 경우 애플리케이션이 여러 TCP+TLS 연결을 해야 했던 때보다 HTTP/2에서 제공하는 TCP 연결 다중화를 통해 네트워크 대역폭을 더 잘 활용할 수 있게 되었지만, 이는  동일한 TCP 연결을 통해 여러 요청과 응답이 전송되기 때문에 모든 요청이 다 Head-Of-Line Blocking에 영향을 받게 되었다. 


## 제안 방안

Google은 기존 TCP 연결에서 발생한 문제들을 해결할 수 있는 프로토콜인 QUIC을 제안한다. QUIC은 UDP 기반으로, 새로운 연결을 설정하는 데 0-RTT(Round Trip Time) 및 1-RTT를 모두 제공하며 UDP는 신뢰할 수 있는 전송이 아니지만 QUIC은 UDP 위에 안정성을 도입하는 레이어를 추가하며 패킷 재전송, 혼잡 제어 등 TCP의 다양한 기능들을 제공한다. 이를 통해 TCP로 인한 느린 연결 설정과 Head-Of-Line Blocking 문제를 해결할 수 있게 되었다. 본 논문에서는 QUIC stream을 병렬로 연결하여 파일을 분할 전송하는 방식을 제안하며, 기존 TCP+TLS 병렬 연결을 통한 파일 전송 방식과 비교하고, 성능 차이를 분석하고자 한다.


## 실험 결과 및 결과 고찰
### 서버 SW 설계 및 개발
실험에 사용된 서버 SW는 전송할 파일을 일정한 크기로  chunk 형태로 분할하게 된다. 분할되는 chunk의 수는 실험 시 클라이언트와 수립되는 연결의 수와 같다. 각각의 chunk는 번호가 매겨지며, 각각의 연결 당 한 개의 chunk를 전달하게 된다. 각 연결들을 통한 멀티스레딩을 통해 동시에 이뤄진다.
TCP 연결의 경우, TLS 연결 없이 순수 TCP 연결만 1개\~6개로 전송하는 경우와 TLS 연결을 포함한 TCP 연결 1개\~6개로 전송하는 경우를 각각 측정하며, QUIC 또한 Stream을 1개~6개로 늘려가며 파일을 분할 전송하게 된다.
서버 SW는 Golang을 이용, github.com/lucas-clemente/quic-go 라이브러리를 통해 QUIC 전송을 구현했으며, TCP는 기본 패키지 net을 통해 전송을 구현했다. TCP+TLS는 crypto/tls 패키지를 통해 구현했다.
TCP(+TLS) 서버는 나눠진 chunk들을 전송할 수 있도록 chunk당 하나의 TCP(+TLS) 연결을 생성한다. 그리고 각각의 chunk들을 연결을 통해 전송한다. chunk 순서는 클라이언트가 연결을 시도하는 순서와 같다. 주어진 chunk를 모두 전송한 경우, TCP(+TLS) 연결을 종료하며 클라이언트 측에 EOF를 전달한다.
QUIC 서버는 마찬가지로 나눠진 chunk들을 전송할 수 있도록 chunk당 하나의 stream 연결을 생성한다. 그리고 각각의 chunk들을 stream을 통해 전송한다. chunk의 순서 또한 TCP와 마찬가지로 클라이언트가 연결을 시도하는 순서와 같다. 주어진 chunk를 모두 전송하게 되면 EOF를 전송한 후 QUIC stream이 닫히게 되고, 모든 전송이 완료되어 모든 stream이 닫히게 되면 QUIC 연결이 끊어진다. 이 부분에서 클라이언트에 모든 데이터들이 도달하기 전에 서버는 모든 파일을 전송 완료 후 stream을 닫아버리게 되면 QUIC 연결이 끊기고 마지막 1\~2개정도의 버퍼가 클라이언트에 도달하지 않는 문제가 있으므로, 모든 전송이 완료되었는지를 확인할 수 있는 별도의 stream을 열어 클라이언트가 모든 파일 수신을 완료한 후 보내는 신호를 수신 후 stream을 닫아 조기에 QUIC 연결이 끊어지는 것을 방지해야 한다.

### 클라이언트 SW 설계 및 개발
클라이언트는 서버에 연결 후 서버가 보내는 모든 chunk 파일들을 받는다. 연결 시도 순서가 chunk 순서와 같기 때문에 연결 순서대로 받은 chunk에 똑같이 번호를 매긴후, 원래 파일과 같은 형태로 합쳐주는 과정을 거친다. 파일 수신 또한 서버와 마찬가지로 멀티스레딩을 통해 동시에 이루어진다. 모든 클라이언트는 시작 시간부터 연결 완료 시간, 전송 완료 시간을 각각 로그를 통해 출력하여 작업 시간을 측정한다.
TCP(+TLS) 클라이언트는 서버와 동일한 수의 TCP(+TLS) 연결을 진행하며, 각각의 연결을 통해 서버가 보낸 EOF를 받으면 수신을 종료하고 연결을 닫는다.  모든 파일을 다 수신하면 수신한 모든 chunk를 순서에 맞춰 하나로 합쳐준다.
TCP+TLS 클라이언트에서 서버로 복수로 연결을 시도할 시, 앞서 연결된 TCP+TLS를 통해 데이터가 한번도 이동하지 않았다면 이후 시도되는 연결은 앞의 연결과 동일한 연결 시도(동일한 인증서 사용으로 인함)로 파악해 TCP+TLS 연결의 경우 매 연결 시작 직후 데이터를 전송해 다른 연결 시도임을 확인시킨다.
QUIC 클라이언트는 마찬가지로 서버와 동일한 수의 QUIC stream을 통해 파일 chunk들을 수신하게 되며, 추가로 stream을 하나 더 열어 모든 연결을 통해 서버로부터 EOF를 수신하고 정상적으로 파일을 모두 받은 것을 확인하면 서버를 닫아도 괜찮다는 신호를 보내게 된다. 그렇게 연결이 모두 끊어진 뒤, 받은 chunk들을 하나의 파일로 합쳐준다.


### 근거리 네트워킹 실험
근거리 네트워킹 실험에서는 동일한 기기 상에서 서버와 클라이언트를 각각 실행한 환경에서 파일을 전송 성능을 측정한다. 해당 실험 환경의 Round Trip Time은 min/avg/max/stddev = 0.037/0.079/0.149/0.026 ms 정도이다. TCP, TCP+TLS, QUIC 각각 1개에서 6개로 연결을 병렬로 늘려가며 실험하였으며 각 케이스마다 10회 전송 후 평균 시간을 측정한다. 
QUIC > TCP+TLS > TCP 순서로 전송 시간이 오래 걸린 것을 확인할 수 있다. RTT의 값이 극도로 짧은 환경에서는 오히려 데이터 전송 횟수보단 연산 속도가 전체 전송 시간에 큰 영향을 미쳤으며, 이에 따라 QUIC의 전송 처리에 필요한 시간이 더 긴 것을 확인할 수 있다. 


### 장거리 네트워킹 실험
장거리 네트워킹 실험 환경 구축을 위해서는 AWS EC2 서비스를 이용했다. us-east-1 서버(미국 동부 - 버지니아 북부)를 이용하여, 2 vCPU와 4 GiB 메모리의 t2.medium 인스턴스로 서버를 동작했다. 해당 실험 환경의 Round Trip Time은 min/avg/max/stddev = 194.567/195.514/208.020/1.646 ms 정도이다. 마찬가지로 TCP, CP+TLS, QUIC 각각 1개에서 6개로 연결을 병렬로 늘려가며 실험하였으며 각 케이스마다 10회 전송 후 평균 시간을 측정한다. 
장거리 네트워킹 환경의 경우, TCP+TLS > TCP > QUIC 순서로 전송 시간이 오래 걸린 것을 확인할 수 있다. 특히, TCP나 TCP+TLS의 경우 병렬로 연결을 다수 진행할 경우 그만큼 전송 시간에서 손해를 보았다.

그림 6은 TCP, TCP+TLS, QUIC 연결을 병렬로 복수로 연결할 경우 걸리는 시간을 비교한 그래프이다. QUIC의 경우 stream의 수를 늘려도 연결 시간이 더 증가하는 모습을 보이지 않은 반면, TCP나 TCP+TLS 연결의 경우 연결 수를 늘릴수록 연결 시간이 선형으로 증가하는 모습을 보였다. 그로 인해 전체적인 전송 완료까지의 시간이 늦춰졌으며, 그림6과 같이 전송 시간에서 손해를 보게 된 것이라 할 수 있다.


### 알게 된 점과 제안 사항
성능 측정 결과, 장거리 네트워킹 환경에서 파일을 내려받는 경우, TCP 혹은 TCP+TLS 연결보다 QUIC이 더 좋은 성능을 보이는 것을 확인할 수 있었으며, 복수 개의 연결을 병렬로 추가로 연결해서 분할 전송을 진행함에 있어서도 QUIC은 stream을 추가하는데 추가적인 시간 소모 없이 보다 빠른 속도로 파일을 전송할 수 있음을 알 수 있었다.
기존 FTP와 같이 신뢰성을 보장하는 전송을 필요로 하는 프로토콜에서 TCP를 사용했다면, QUIC을 사용한 파일 전송이 충분한 대안이 될 수 있다. 또한 여러 개의 파일을 동시에 내려받을 경우 TCP 대신 QUIC을 사용할 경우 Head-Of-Line Blocking 문제 해결 뿐만 아니라 연결 속도 향상으로 추가적인 파일 전송 속도 향상을 기대할 수 있을 것으로 보인다.
뿐만 아니라 이를 웹 상에 적용할 경우, 브라우저가 웹 페이지를 렌더링하기 위해 CSS, javascript, image 등의 asset을 가져와야하는 경우, TCP 대신 QUIC을 통해 해당 asset들을 병렬로 동시에 더 빠르게 가져오면서 웹 페이지를 빠르게 렌더링하고, 사용자 이탈을 막는 데 더 효과적일 것으로 예상된다.


## 결론
본 논문에서는 파일 분할 전송을 대상으로 golang 언어 기반 QUIC, TCP, TCP+TLS의  성능의 비교분석을 수행하였다. QUIC 프로토콜은 기존 TCP를 통한 전송의 문제점으로 지적되었던 느린 연결 시간과 Head-Of-Line Blocking 문제를 해결하기 위해 제안되었고, 실험 결과 QUIC을 병렬로 다수의 연결을 진행할 경우 연결 시간을 크게 단축시킬 수 있었으며, 전체적인 파일의 전송 속도도 향상시킬 수 있는 것을 확인하였다.
파일 전송 등의 목적으로 신뢰성을 보장하는 전송이 필요해 TCP+TLS 연결을 사용하던 경우, QUIC 프로토콜로 변경 시 연결 속도 향상 및 Head-Of-Line Blocking 문제 해결을 통한 전송 속도 향상을 기대할 수 있을 것으로 보인다. 
